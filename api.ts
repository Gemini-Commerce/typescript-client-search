/* tslint:disable */
/* eslint-disable */
/**
 * Search Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: info@gemini-commerce.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ParamSortOrder = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type ParamSortOrder = typeof ParamSortOrder[keyof typeof ParamSortOrder];


/**
 * 
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    'typeUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
    /**
     * 
     * @type {number}
     * @memberof RpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RpcStatus
     */
    'details'?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface SearchAggrMap
 */
export interface SearchAggrMap {
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchAggrMap
     */
    'results'?: Array<string>;
}
/**
 * contains all the necessary to create or update an index
 * @export
 * @interface SearchConfigRequest
 */
export interface SearchConfigRequest {
    /**
     * tenant_id for which create or update indexes configuration [#DOCGENBUG REQUIRED FIELD]
     * @type {string}
     * @memberof SearchConfigRequest
     */
    'tenantId'?: string;
    /**
     * contains index configurations fields [#DOCGENBUG REQUIRED FIELD]
     * @type {Array<SearchConfigSchema>}
     * @memberof SearchConfigRequest
     */
    'configSchema'?: Array<SearchConfigSchema>;
}
/**
 * contains index configurations fields
 * @export
 * @interface SearchConfigSchema
 */
export interface SearchConfigSchema {
    /**
     * index name, to create or where update configuration
     * @type {string}
     * @memberof SearchConfigSchema
     */
    'index': string;
    /**
     * field which value will be used as document id [#DOCGENBUG REQUIRED FIELD]
     * @type {string}
     * @memberof SearchConfigSchema
     */
    'documentKeyName'?: string;
    /**
     * fields that can be stored into index and later retrieved
     * @type {Array<SearchConfigSchemaAttribute>}
     * @memberof SearchConfigSchema
     */
    'attributes': Array<SearchConfigSchemaAttribute>;
    /**
     * fields that can be used for fulltext searches
     * @type {Array<SearchConfigSchemaSearchable>}
     * @memberof SearchConfigSchema
     */
    'searchables'?: Array<SearchConfigSchemaSearchable>;
    /**
     * fields that can be used for aggregations
     * @type {Array<SearchConfigSchemaFacet>}
     * @memberof SearchConfigSchema
     */
    'facets'?: Array<SearchConfigSchemaFacet>;
    /**
     * fields that can be used for filtering
     * @type {Array<SearchConfigSchemaFilter>}
     * @memberof SearchConfigSchema
     */
    'filters'?: Array<SearchConfigSchemaFilter>;
    /**
     * fields that can be used for sorting
     * @type {Array<SearchConfigSchemaSortable>}
     * @memberof SearchConfigSchema
     */
    'sortables'?: Array<SearchConfigSchemaSortable>;
}
/**
 * contains the configurations needed to define an attribute within documents
 * @export
 * @interface SearchConfigSchemaAttribute
 */
export interface SearchConfigSchemaAttribute {
    /**
     * attribute name
     * @type {string}
     * @memberof SearchConfigSchemaAttribute
     */
    'name': string;
    /**
     * 
     * @type {SearchConfigSchemaAttributeType}
     * @memberof SearchConfigSchemaAttribute
     */
    'type'?: SearchConfigSchemaAttributeType;
    /**
     * locale code (currently only it_IT and en_US are supported)
     * @type {string}
     * @memberof SearchConfigSchemaAttribute
     */
    'language'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SearchConfigSchemaAttributeType = {
    Text: 'TEXT',
    Boolean: 'BOOLEAN',
    Integer: 'INTEGER',
    Float: 'FLOAT',
    Date: 'DATE',
    Object: 'OBJECT'
} as const;

export type SearchConfigSchemaAttributeType = typeof SearchConfigSchemaAttributeType[keyof typeof SearchConfigSchemaAttributeType];


/**
 * contains the configurations needed to define an aggregation (Facet) using defined index attributes
 * @export
 * @interface SearchConfigSchemaFacet
 */
export interface SearchConfigSchemaFacet {
    /**
     * json array of attributes of index that you can use as aggregation to make facets
     * @type {string}
     * @memberof SearchConfigSchemaFacet
     */
    'attribute': string;
}
/**
 * contains the configurations needed to define which index attributes can be used as filter
 * @export
 * @interface SearchConfigSchemaFilter
 */
export interface SearchConfigSchemaFilter {
    /**
     * json array of attributes of index that you can use to filter search results
     * @type {string}
     * @memberof SearchConfigSchemaFilter
     */
    'attribute': string;
}
/**
 * contains the configurations needed to define which index attributes can be used for search
 * @export
 * @interface SearchConfigSchemaSearchable
 */
export interface SearchConfigSchemaSearchable {
    /**
     * json array of attributes of index which can be used for search
     * @type {string}
     * @memberof SearchConfigSchemaSearchable
     */
    'attribute': string;
}
/**
 * contains the configurations needed to define which index attributes can be used for sort
 * @export
 * @interface SearchConfigSchemaSortable
 */
export interface SearchConfigSchemaSortable {
    /**
     * json array of attributes of index which can be used for sort
     * @type {string}
     * @memberof SearchConfigSchemaSortable
     */
    'attribute': string;
}
/**
 * 
 * @export
 * @interface SearchDeleteConstraints
 */
export interface SearchDeleteConstraints {
    /**
     * 
     * @type {string}
     * @memberof SearchDeleteConstraints
     */
    'index'?: string;
}
/**
 * 
 * @export
 * @interface SearchDeleteError
 */
export interface SearchDeleteError {
    /**
     * 
     * @type {SearchDeleteConstraints}
     * @memberof SearchDeleteError
     */
    'constraints'?: SearchDeleteConstraints;
    /**
     * 
     * @type {string}
     * @memberof SearchDeleteError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchDeleteError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SearchDeleteRequest
 */
export interface SearchDeleteRequest {
    /**
     * tenant_id for which remove costraints [#DOCGENBUG REQUIRED FIELD]
     * @type {string}
     * @memberof SearchDeleteRequest
     */
    'tenantId'?: string;
    /**
     * constraints to remove (index name) [#DOCGENBUG REQUIRED FIELD]
     * @type {Array<SearchDeleteConstraints>}
     * @memberof SearchDeleteRequest
     */
    'constraints'?: Array<SearchDeleteConstraints>;
}
/**
 * 
 * @export
 * @interface SearchDeleteResponse
 */
export interface SearchDeleteResponse {
    /**
     * 
     * @type {Array<SearchDeleteError>}
     * @memberof SearchDeleteResponse
     */
    'errors'?: Array<SearchDeleteError>;
}
/**
 * contains a list of document attributes which you want the search returns
 * @export
 * @interface SearchParamAttribute
 */
export interface SearchParamAttribute {
    /**
     * JSON string that contains the list of attributes you want to be returned in search results
     * @type {string}
     * @memberof SearchParamAttribute
     */
    'attribute': string;
}
/**
 * contains a list of document attributes which you want to be returned as aggregations by attribute values to make filter suggestions
 * @export
 * @interface SearchParamFacet
 */
export interface SearchParamFacet {
    /**
     * JSON string that contains the list of attributes you want to create aggregation to make filter suggestion
     * @type {string}
     * @memberof SearchParamFacet
     */
    'attribute': string;
    /**
     * Limit of facets result
     * @type {number}
     * @memberof SearchParamFacet
     */
    'limit'?: number;
    /**
     * 
     * @type {SearchParamFacetType}
     * @memberof SearchParamFacet
     */
    'type'?: SearchParamFacetType;
    /**
     * 
     * @type {string}
     * @memberof SearchParamFacet
     */
    'params'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchParamFacet
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SearchParamFacetType = {
    Terms: 'TERMS',
    Stats: 'STATS',
    Histogram: 'HISTOGRAM'
} as const;

export type SearchParamFacetType = typeof SearchParamFacetType[keyof typeof SearchParamFacetType];


/**
 * contains a list of document attributes and relative values which you want to filter search results
 * @export
 * @interface SearchParamFilter
 */
export interface SearchParamFilter {
    /**
     * JSON string that contains filters information to apply to search
     * @type {string}
     * @memberof SearchParamFilter
     */
    'filter': string;
    /**
     * 
     * @type {SearchParamFilterType}
     * @memberof SearchParamFilter
     */
    'type'?: SearchParamFilterType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SearchParamFilterType = {
    Term: 'TERM',
    Terms: 'TERMS',
    Range: 'RANGE'
} as const;

export type SearchParamFilterType = typeof SearchParamFilterType[keyof typeof SearchParamFilterType];


/**
 * contains a list of attributes where the search term to be searched
 * @export
 * @interface SearchParamSearchable
 */
export interface SearchParamSearchable {
    /**
     * JSON string that contains the list of attributes where to search the indicated term
     * @type {string}
     * @memberof SearchParamSearchable
     */
    'attribute': string;
}
/**
 * contains a list of document attributes on which order the result for
 * @export
 * @interface SearchParamSort
 */
export interface SearchParamSort {
    /**
     * JSON string that contains the list of attributes you want search results to be ordered by
     * @type {string}
     * @memberof SearchParamSort
     */
    'attribute': string;
    /**
     * 
     * @type {ParamSortOrder}
     * @memberof SearchParamSort
     */
    'order'?: ParamSortOrder;
}


/**
 * contains params needed to perform search
 * @export
 * @interface SearchParams
 */
export interface SearchParams {
    /**
     * number of the record where to start to take result for pagination
     * @type {number}
     * @memberof SearchParams
     */
    'offset'?: number;
    /**
     * number of search result for page
     * @type {number}
     * @memberof SearchParams
     */
    'limit'?: number;
    /**
     * term to search
     * @type {string}
     * @memberof SearchParams
     */
    'term'?: string;
    /**
     * list of attributes where to search the indicated term, if not indicated it uses all in those present in index configuration
     * @type {Array<SearchParamSearchable>}
     * @memberof SearchParams
     */
    'searchables'?: Array<SearchParamSearchable>;
    /**
     * list of attribute and relative value which you want to filter search results
     * @type {Array<SearchParamFilter>}
     * @memberof SearchParams
     */
    'filters'?: Array<SearchParamFilter>;
    /**
     * attributes that you want to be present in search results
     * @type {Array<SearchParamAttribute>}
     * @memberof SearchParams
     */
    'attributes'?: Array<SearchParamAttribute>;
    /**
     * list of attributes you want to create aggregation to make filter suggestion
     * @type {Array<SearchParamFacet>}
     * @memberof SearchParams
     */
    'facets'?: Array<SearchParamFacet>;
    /**
     * params to sort search results
     * @type {Array<SearchParamSort>}
     * @memberof SearchParams
     */
    'sorts'?: Array<SearchParamSort>;
    /**
     * 
     * @type {number}
     * @memberof SearchParams
     */
    'minScore'?: number;
}
/**
 * contains the search request payload
 * @export
 * @interface SearchPayload
 */
export interface SearchPayload {
    /**
     * index where to search data
     * @type {string}
     * @memberof SearchPayload
     */
    'index': string;
    /**
     * 
     * @type {SearchParams}
     * @memberof SearchPayload
     */
    'params': SearchParams;
}
/**
 * contains error information obtained during search process
 * @export
 * @interface SearchQueryError
 */
export interface SearchQueryError {
    /**
     * query error code obtained during elastic search query request
     * @type {string}
     * @memberof SearchQueryError
     */
    'code': string;
    /**
     * query error message obtained during elastic search query request
     * @type {string}
     * @memberof SearchQueryError
     */
    'message': string;
}
/**
 * contains search request information about how and where to make the search
 * @export
 * @interface SearchQueryRequest
 */
export interface SearchQueryRequest {
    /**
     * tenant to search on [#DOCGENBUG REQUIRED FIELD]
     * @type {string}
     * @memberof SearchQueryRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {SearchQueryRequestType}
     * @memberof SearchQueryRequest
     */
    'type'?: SearchQueryRequestType;
    /**
     * contains the search request payload
     * @type {Array<SearchPayload>}
     * @memberof SearchQueryRequest
     */
    'payload': Array<SearchPayload>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SearchQueryRequestType = {
    Standard: 'STANDARD',
    AsYouType: 'AS_YOU_TYPE'
} as const;

export type SearchQueryRequestType = typeof SearchQueryRequestType[keyof typeof SearchQueryRequestType];


/**
 * contains the search results and errors
 * @export
 * @interface SearchQueryResponse
 */
export interface SearchQueryResponse {
    /**
     * array of SearchResult that contains search results per index [#DOCGENBUG REQUIRED FIELD]
     * @type {Array<SearchResult>}
     * @memberof SearchQueryResponse
     */
    'result'?: Array<SearchResult>;
    /**
     * array of error obtained during search process per index [#DOCGENBUG REQUIRED FIELD]
     * @type {Array<SearchQueryError>}
     * @memberof SearchQueryResponse
     */
    'errors'?: Array<SearchQueryError>;
}
/**
 * contains the search results, aggregations and paging information
 * @export
 * @interface SearchResult
 */
export interface SearchResult {
    /**
     * index where the data were extrapolated
     * @type {string}
     * @memberof SearchResult
     */
    'index': string;
    /**
     * 
     * @type {SearchParams}
     * @memberof SearchResult
     */
    'params'?: SearchParams;
    /**
     * page number of the results you are processing
     * @type {number}
     * @memberof SearchResult
     */
    'page'?: number;
    /**
     * number of pages of results
     * @type {number}
     * @memberof SearchResult
     */
    'totalPages'?: number;
    /**
     * number of total search results
     * @type {number}
     * @memberof SearchResult
     */
    'totalHits'?: number;
    /**
     * search result records contained in the specified page
     * @type {Array<string>}
     * @memberof SearchResult
     */
    'hits'?: Array<string>;
    /**
     * array of aggregation obtained by search result
     * @type {{ [key: string]: SearchAggrMap; }}
     * @memberof SearchResult
     */
    'aggregations'?: { [key: string]: SearchAggrMap; };
}
/**
 * contain error information obtained during writing process in search storage
 * @export
 * @interface SearchWriteError
 */
export interface SearchWriteError {
    /**
     * error identifier code
     * @type {string}
     * @memberof SearchWriteError
     */
    'code': string;
    /**
     * document key used to identify document
     * @type {string}
     * @memberof SearchWriteError
     */
    'documentKeyName'?: string;
    /**
     * document key identifier
     * @type {string}
     * @memberof SearchWriteError
     */
    'documentKeyValue'?: string;
    /**
     * error description message
     * @type {string}
     * @memberof SearchWriteError
     */
    'message': string;
}
/**
 * contains where and what data to write in search storage
 * @export
 * @interface SearchWriteRequest
 */
export interface SearchWriteRequest {
    /**
     * tenant id data identifier where to write data [#DOCGENBUG REQUIRED FIELD]
     * @type {string}
     * @memberof SearchWriteRequest
     */
    'tenantId'?: string;
    /**
     * elasticsearch index identifier where to write data
     * @type {string}
     * @memberof SearchWriteRequest
     */
    'index': string;
    /**
     * A JSON array of documents to write or update
     * @type {Array<string>}
     * @memberof SearchWriteRequest
     */
    'documents': Array<string>;
}
/**
 * contains write operation result response from search service
 * @export
 * @interface SearchWriteResponse
 */
export interface SearchWriteResponse {
    /**
     * elasticsearch index where the write request was processed
     * @type {string}
     * @memberof SearchWriteResponse
     */
    'index': string;
    /**
     * array of errors obtained during elasticsearch documents write or update
     * @type {Array<SearchWriteError>}
     * @memberof SearchWriteResponse
     */
    'errors'?: Array<SearchWriteError>;
}

/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create or update indexes by a passed configuration schema
         * @summary Indexes configuration
         * @param {SearchConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchConfiguration: async (body: SearchConfigRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('searchConfiguration', 'body', body)
            const localVarPath = `/search.Search/Configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication geminiAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "X-Gem-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete indexes from ElasticSearch and Cassandra configuration
         * @summary Delete Indexes
         * @param {SearchDeleteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDelete: async (body: SearchDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('searchDelete', 'body', body)
            const localVarPath = `/search.Search/Delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication geminiAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "X-Gem-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert or replace a document or more in a specified ElasticSearch index of a tenant
         * @summary Insert or replace documents to different elasticsearch indexes
         * @param {SearchWriteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInsertOrReplace: async (body: SearchWriteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('searchInsertOrReplace', 'body', body)
            const localVarPath = `/search.Search/InsertOrReplace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication geminiAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "X-Gem-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * MSearch promises to send a list of queries to elasticsearch to be executed on different indexes, it can also be used as an autocomplete by adding the corresponding TYPE
         * @summary Send queries to different elasticsearch indexes
         * @param {SearchQueryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMSearch: async (body: SearchQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('searchMSearch', 'body', body)
            const localVarPath = `/search.Search/MSearch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication geminiAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "X-Gem-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a document or more in a specified ElasticSearch index of a tenant
         * @summary Update documents to different elasticsearch indexes
         * @param {SearchWriteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUpdate: async (body: SearchWriteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('searchUpdate', 'body', body)
            const localVarPath = `/search.Search/Update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication geminiAuthorization required
            await setApiKeyToObject(localVarHeaderParameter, "X-Gem-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Create or update indexes by a passed configuration schema
         * @summary Indexes configuration
         * @param {SearchConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchConfiguration(body: SearchConfigRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchConfiguration(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchConfiguration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete indexes from ElasticSearch and Cassandra configuration
         * @summary Delete Indexes
         * @param {SearchDeleteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDelete(body: SearchDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDelete(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Insert or replace a document or more in a specified ElasticSearch index of a tenant
         * @summary Insert or replace documents to different elasticsearch indexes
         * @param {SearchWriteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInsertOrReplace(body: SearchWriteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchWriteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInsertOrReplace(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchInsertOrReplace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * MSearch promises to send a list of queries to elasticsearch to be executed on different indexes, it can also be used as an autocomplete by adding the corresponding TYPE
         * @summary Send queries to different elasticsearch indexes
         * @param {SearchQueryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMSearch(body: SearchQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchQueryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMSearch(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchMSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a document or more in a specified ElasticSearch index of a tenant
         * @summary Update documents to different elasticsearch indexes
         * @param {SearchWriteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUpdate(body: SearchWriteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchWriteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUpdate(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Create or update indexes by a passed configuration schema
         * @summary Indexes configuration
         * @param {SearchConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchConfiguration(body: SearchConfigRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.searchConfiguration(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete indexes from ElasticSearch and Cassandra configuration
         * @summary Delete Indexes
         * @param {SearchDeleteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDelete(body: SearchDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchDeleteResponse> {
            return localVarFp.searchDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Insert or replace a document or more in a specified ElasticSearch index of a tenant
         * @summary Insert or replace documents to different elasticsearch indexes
         * @param {SearchWriteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInsertOrReplace(body: SearchWriteRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchWriteResponse> {
            return localVarFp.searchInsertOrReplace(body, options).then((request) => request(axios, basePath));
        },
        /**
         * MSearch promises to send a list of queries to elasticsearch to be executed on different indexes, it can also be used as an autocomplete by adding the corresponding TYPE
         * @summary Send queries to different elasticsearch indexes
         * @param {SearchQueryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMSearch(body: SearchQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchQueryResponse> {
            return localVarFp.searchMSearch(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a document or more in a specified ElasticSearch index of a tenant
         * @summary Update documents to different elasticsearch indexes
         * @param {SearchWriteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUpdate(body: SearchWriteRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchWriteResponse> {
            return localVarFp.searchUpdate(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Create or update indexes by a passed configuration schema
     * @summary Indexes configuration
     * @param {SearchConfigRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchConfiguration(body: SearchConfigRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchConfiguration(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete indexes from ElasticSearch and Cassandra configuration
     * @summary Delete Indexes
     * @param {SearchDeleteRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchDelete(body: SearchDeleteRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchDelete(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Insert or replace a document or more in a specified ElasticSearch index of a tenant
     * @summary Insert or replace documents to different elasticsearch indexes
     * @param {SearchWriteRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchInsertOrReplace(body: SearchWriteRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchInsertOrReplace(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * MSearch promises to send a list of queries to elasticsearch to be executed on different indexes, it can also be used as an autocomplete by adding the corresponding TYPE
     * @summary Send queries to different elasticsearch indexes
     * @param {SearchQueryRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchMSearch(body: SearchQueryRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchMSearch(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a document or more in a specified ElasticSearch index of a tenant
     * @summary Update documents to different elasticsearch indexes
     * @param {SearchWriteRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchUpdate(body: SearchWriteRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }
}



